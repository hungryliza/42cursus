nano /etc/bash.bashrc

path = /home/limelo-c/monitoring.sh

path to signature : 

shasum Born2beRoot.vdi

daa2c61322d89daab3e5e7ba834e7fd64c69de08

path to password rules

sudo nano /etc/pam.d/common-password

sudo policies 

nano /etc/sudoers.d/sudo_config

sudo systemctl status <coisa>

sudo ufw status numbered

sudo ufw delete <numero>

passer a l' autre user 

exit 

puis password

changer le host

sudo nano /etc/hostname et /hosts

arreter le script sans toucher le script

sudo crontab -e

voir partitions 

sudo lsblk

ajouter regle

ufw status numbered

ufw allow 8080

ufw delete <numero>

script

grep "physical id" /proc/cpuinfo | wc -l to get number of physical cores 

grep processor /proc/cpuinfo | wc -l to get number of virtual cores

free --mega | awk '$1 == "Mem:" {print $3}' to get number mb of used memoir

free --mega | awk '$1 == "Mem:" {print $2}' to get number of total mb memoire

free --mega | awk '$1 == "Mem:" {printf("(%.2f%%)\n", $3/$2*100)}' to get pourcent of used memory

To view the occupied and available memory of the disk, we will use the df command, which stands for "disk filesystem", it is used to get a complete summary of the use of disk space. 

The used memory is shown in MB, so we will then use the -m flag.

Next, we will do a grep to only show us the lines that contain "/dev/" and then we will do another grep with the -v flag to exclude lines that contain "/boot". Finally, we will use the awk command and sum the value of the third word of each line to once all the lines are summed, print the final result of the sum. The entire command is as follows: df -m | grep "/dev/" | grep -v "/boot" | awk '{memory_use += $3} END {print memory_use}'

df -m | grep "/dev/" | grep -v "/boot" | awk '{use += $3} {total += $2} END {printf("(%d%%)\n"), use/total*100}' to get number of occuped disk memory

Random theorical quaestions

Reading from disk is several orders of magnitude slower than reading from memory, so this slows everything way down. (Exchanging data between real memory and virtual memory is "swapping". The space on disk is "swap space".)

lsblk (list block devices) is a Linux command-line utility that displays information about all available block devices (like hard drives, SSDs, USB drives, partitions, and loop devices) in a clear, tree-like format, showing their relationships, sizes, and mount points
making it essential for understanding storage configuration on a system.
The
requiretty option in the Linux sudo configuration file (/etc/sudoers) mandates that a user must be connected to a real TTY (teletypewriter, or terminal session) to run commands using sudo
difok
(different from old) is a Linux password policy setting in the pwquality.conf file that defines the minimum number of characters that must be changed (inserted, deleted, or substituted) between a user's new password and their previous one, preventing simple modifications and enforcing password strength by checking the "distance" between passwords using the Levenshtein distance algorithm

Yes, AppArmor is built into the Linux kernel
and is often pre-installed and enabled by default on many distributions like Ubuntu and Debian, acting as a mandatory access control (MAC) system to restrict program capabilities with profiles. 

LVM

LVM (Logical Volume Manager) is a Linux storage virtualization tool that provides a flexible layer between physical disks and the file system, allowing administrators to create, resize, and manage storage dynamically, even spanning multiple drives, without interrupting system use.

encrypted LVM

When you use this option, the installer creates a few partitions: a /boot partition, which is used to store the kernel and bootloader; depending on your system, a special firmware (e.g., EFI) partition; and an encrypted partition which contains a single LVM physical volume.

Inside that encrypted LVM physical volume, there is a root partition and usually a swap partition, plus any additional partitions you want. All of these partitions are encrypted, but the /boot and /boot/efi partitions are not.

It is never possible to encrypt the EFI partition, since the firmware doesn't know how to boot it in such a state. It is possible, but uncommon, to encrypt the /boot partition; grub requires special configuration to do so, which Debian doesn't implement by default.

The requiretty option in the Linux sudo configuration file (/etc/sudoers) mandates that a user must be connected to a real TTY (teletypewriter, or terminal session) to run commands using sudo

TTY Requirement: The primary function is to prevent sudo from being run from non-interactive sessions, such as automated scripts (cron jobs, CGI scripts, or remote SSH commands without explicit TTY allocation)Introduction

Cron is a time-based job scheduler in Unix-like operating systems (Linux, macOS) that automates repetitive tasks by running commands or scripts at specified intervals, like daily backups, system maintenance, or sending reports, configured through crontab files using a syntax of minute, hour, day, month, and day of week. 

difok (different characters) is a Linux password policy setting in the pam_pwquality module that defines the minimum number of characters that must change between a new password and the old one, preventing users from making trivial changes and enhancing security against brute-force attacks

script 

#!/bin/bash

    Shebang
    Tells the system to run this script using the Bash shell. 

# ARCH
arch=$(uname -a)

    uname -a prints system information (kernel, OS, architecture, hostname).
    
    $(...) captures the output.
    
    Stored in variable arch.

# CPU PHYSICAL
cpuf=$(grep "physical id" /proc/cpuinfo | wc -l)

    /proc/cpuinfo contains CPU information.

    grep "physical id" finds physical CPU IDs.

    wc -l counts the number of lines → number of physical CPUs.

    Stored in cpuf.


# CPU VIRTUAL
cpuv=$(grep "processor" /proc/cpuinfo | wc -l)

    Each processor entry represents a logical CPU / thread.

    Counts virtual CPUs (vCPUs).

    Stored in cpuv.


# RAM
ram_total=$(free --mega | awk '$1 == "Mem:" {print $2}')

    free --mega shows memory in MB.
    
    awk selects the Mem: line.
    
    $2 is total RAM.
    
    Stored in ram_total.

ram_use=$(free --mega | awk '$1 == "Mem:" {print $3}')

    $3 is used RAM.
    
    Stored in ram_use.

ram_percent=$(free --mega | awk '$1 == "Mem:" {printf("%.2f"), $3/$2*100}')

    Calculates RAM usage percentage.

    $3/$2*100 → used ÷ total × 100
    
    printf("%.2f") formats to 2 decimal places.
    
    Stored in ram_percent.

# DISK
disk_total=$(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_t += $2} END {printf ("%.1fGb\n"), disk_t/1024}')

    df -m shows disk usage in MB.
    
    grep "/dev/" keeps real disks.
    
    grep -v "/boot" excludes boot partition.
    
    $2 is total disk size (MB).
    
    Adds all disks together.
    
    Converts MB → GB (/1024).
    
    Stored in disk_total.

disk_use=$(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_u += $3} END {print disk_u}')

    $3 is used disk space.

    Sums used space of all disks.

    Stored in disk_use.

disk_percent=$(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_u += $3} {disk_t+= $2} END {printf("%d"), disk_u/disk_t*100}')

    Calculates disk usage percentage.
    
    disk_u / disk_t * 100
    
    No decimals (%d).
    
    Stored in disk_percent.


# CPU LOAD
cpul=$(vmstat 1 2 | tail -1 | awk '{printf $15}')

    vmstat 1 2: takes 2 samples, 1 second apart.

    tail -1: uses the latest result.

    $15 = CPU idle percentage.

    Stored in cpul.

cpu_op=$(expr 100 - $cpul)
    
    CPU usage = 100 - idle.
    
    Stored in cpu_op.

cpu_fin=$(printf "%.1f" $cpu_op)

    Formats CPU usage to 1 decimal place.
    
    Stored in cpu_fin.

# LAST BOOT
lb=$(who -b | awk '$1 == "system" {print $3 " " $4}')

    who -b shows last system boot time.
    
    Extracts date and time.
    
    Stored in lb.

# LVM USE
lvmu=$(if [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]; then echo yes; else echo no; fi)

    lsblk lists block devices.
    
    Checks if any device uses LVM.
    
    If found → yes, else → no.
    
    Stored in lvmu.

# TCP CONNEXIONS
tcpc=$(ss -ta | grep ESTAB | wc -l)

    ss -ta lists TCP connections.

    ESTAB means established connections.

    Counts them.

    Stored in tcpc.

# USER LOG
ulog=$(users | wc -w)

    users shows logged-in users.
    
    wc -w counts them.
    
    Stored in ulog.

# NETWORK
ip=$(hostname -I)

    Shows all IP addresses of the machine.
    
    Stored in ip.

mac=$(ip link | grep "link/ether" | awk '{print $2}')

    ip link shows network interfaces.
    
    link/ether lines contain MAC addresses.
    
    Extracts MAC address.
    
    Stored in mac.

# SUDO
cmnd=$(journalctl _COMM=sudo | grep COMMAND | wc -l)

    Reads system logs for sudo.

    Counts how many sudo commands were run.

    Stored in cmnd.

wall "	Architecture: $arch
	CPU physical: $cpuf
	vCPU: $cpuv
	Memory Usage: $ram_use/${ram_total}MB ($ram_percent%)
	Disk Usage: $disk_use/${disk_total} ($disk_percent%)
	CPU load: $cpu_fin%
	Last boot: $lb
	LVM use: $lvmu
	Connections TCP: $tcpc ESTABLISHED
	User log: $ulog
	Network: IP $ip ($mac)
	Sudo: $cmnd cmd"

wall sends a message to all logged-in users.

Displays all collected system information in a formatted block.

